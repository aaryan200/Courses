/*
C++ program to check if a sudoku is valid using mulithreading with Openmp
Author: Aaryan
Roll number: CO21BTECH11001
*/

#include <stdio.h>
#include<stdlib.h>
#include<stdbool.h>
#include<math.h>
#include<string.h>
#include <pthread.h>
#include<omp.h>
#include <sys/stat.h>
#include<sys/time.h>
#include <time.h>
#define M 1.0e6

int N,n,k;
int** sudoku;

/*A structure to pass arguments to a thread*/
struct thread_args
{
    int* start_row;
    int* start_col;
    int* end_row;
    int* end_col;
    bool* check;
    int size;
};

/*Please give name of input file in command line argument*/
int main(int argc, char **argv)
{
    /*read input file*/
    FILE *input = fopen(argv[1], "r");
    if (input == NULL)
    {
        printf("%s: File doesn't exist\n", argv[1]);
        return 0;
    }
    // Output file to be generated by main thread
    FILE *out_file = fopen("output_openmp.txt", "w");

    // Number of points, number of threads
    if (fscanf(input, "%d %d", &k, &N) != EOF)
    {
        omp_set_num_threads(k);
        int mod = (3*N)%k, div = (3*N)/k;
        n = sqrt(N);
        
        sudoku = (int**)malloc(N*sizeof(int*));
        for (int i=0;i<N;i++) sudoku[i] = (int*)malloc(N*sizeof(int));

        for (int i=0;i<N;i++) {
            for (int j=0;j<N;j++) fscanf(input,"%d",&sudoku[i][j]);
        }

        // Array of arguments to be passed to threads
        struct thread_args arguments[k];

        int count_rows = 0, count_cols = 0, count_grids = 0;

        for (int i = 0; i < k; i++)
        {
            int extra = 0;
            if (mod>0) {
                extra++;
                mod--;
            }
            int size = div+extra;
            int it = 0;
            arguments[i].size = size;
            arguments[i].start_row = (int*)malloc((size)*sizeof(int));
            arguments[i].start_col = (int*)malloc((size)*sizeof(int));
            arguments[i].end_row = (int*)malloc((size)*sizeof(int));
            arguments[i].end_col = (int*)malloc((size)*sizeof(int));
            arguments[i].check = (bool*)malloc((size)*sizeof(bool));
            while (it<size && count_rows < N) {
                arguments[i].start_row[it] = count_rows;
                arguments[i].start_col[it] = 0;
                arguments[i].end_row[it] = count_rows;
                arguments[i].end_col[it] = N-1;
                arguments[i].check[it] = false;
                it++;
                count_rows++;
            }
            while (it<size && count_cols < N) {
                arguments[i].start_row[it] = 0;
                arguments[i].start_col[it] = count_cols;
                arguments[i].end_row[it] = N-1;
                arguments[i].end_col[it] = count_cols;
                arguments[i].check[it] = false;
                it++;
                count_cols++;
            }
            while (it<size && count_grids < N) {
                int temp = count_grids/n;
                arguments[i].start_row[it] = temp*n;
                arguments[i].start_col[it] = (count_grids%n)*n;
                arguments[i].end_row[it] = arguments[i].start_row[it] + n-1;
                arguments[i].end_col[it] = arguments[i].start_col[it] + n-1;
                arguments[i].check[it] = false;
                it++;
                count_grids++;
            }
        }
        
        // Track of time
        double time_taken = 0.0;
        // clock_t begin = clock();
        struct timeval start, end;
        // start timer.
        gettimeofday(&start, NULL);

        #pragma omp parallel for
        for (int th=0;th<k;th++) {
            int* arr;
            arr = (int*)calloc(N,sizeof(int));
            for (int i=0;i<arguments[th].size;i++) {
                memset(arr,0,N*sizeof(int));
                bool temp_check = true;
                for (int row = arguments[th].start_row[i];row<=arguments[th].end_row[i];row++) {
                    for (int col = arguments[th].start_col[i];col<=arguments[th].end_col[i];col++) {
                        arr[sudoku[row][col]-1]++;
                    }
                }
                for (int j = 0;j<N;j++) {
                    if (arr[j]!=1) {
                        temp_check = false;
                    }
                }
                arguments[th].check[i] = temp_check;
            }
            free(arr);
        }

        // clock_t end = clock();
        // // Total time spent in microseconds
        gettimeofday(&end, NULL);
        time_taken = (end.tv_sec - start.tv_sec) * M;
        time_taken = (time_taken + (end.tv_usec - start.tv_usec));
        printf("%.4lf\n",time_taken);
        // time_taken += (double)(end - begin) * (M) / CLOCKS_PER_SEC;

        bool final_check = true;

        // Print log in output file
        for (int i = 0; i < k; i++)
        {
            for (int j= 0;j<arguments[i].size;j++) {
                if (arguments[i].start_row[j] == arguments[i].end_row[j]) {
                    fprintf(out_file,"Thread %d checks row %d and is ",i+1,arguments[i].start_row[j]+1);
                }
                else if (arguments[i].start_col[j] == arguments[i].end_col[j]) {
                    fprintf(out_file,"Thread %d checks column %d and is ",i+1,arguments[i].start_col[j]+1);
                }
                else {
                    int quot = arguments[i].start_row[j]/n;
                    int rem = arguments[i].start_col[j]/n;
                    fprintf(out_file,"Thread %d checks grid %d and is ",i+1,n*quot+rem+1);
                }
                if (arguments[i].check[j]) fprintf(out_file, "valid\n");
                else {
                    fprintf(out_file, "invalid\n");
                    final_check = false;
                }
            }
        }
        fprintf(out_file,"\n");
        if (final_check) {
            fprintf(out_file,"Sudoku is valid\n");
            printf("Sudoku is valid\n");
        }
        else {
            fprintf(out_file,"Sudoku is invalid\n");
            printf("Sudoku is valid\n");
        }

        // Print time taken in output file
        fprintf(out_file, "The total time taken is %.1lf \xC2\xB5s", time_taken);
        
        fclose(input);
        fclose(out_file);
        for (int i=0;i<N;i++) free(sudoku[i]);
        free(sudoku);
        for (int i = 0; i < k; i++) {
            free(arguments[i].start_row);
            free(arguments[i].start_col);
            free(arguments[i].end_row);
            free(arguments[i].end_col);
            free(arguments[i].check);
        }
    }
    else
    {
        printf("No input written in the file\n");
    }
    return 0;
}