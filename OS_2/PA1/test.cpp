/*
C++ program to check if a sudoku is valid using mulithreading with pthreads
Author: Aaryan
Roll number: CO21BTECH11001
*/

#include <stdio.h>
#include<stdlib.h>
#include<stdbool.h>
#include<math.h>
#include<string.h>
#include <pthread.h>
#include <sys/stat.h>
#include<sys/time.h>
#include <chrono>
using namespace std;
using namespace std::chrono;
#define M 1.0e6

/*A structure to pass arguments to a thread*/
struct thread_args
{
    int** temp_sudoku;
    int* start_row;
    int* start_col;
    int* end_row;
    int* end_col;
    bool* check;
    int size;
    int N;
};

/*Runner function of thread*/
void *runner(void *args)
{
    struct thread_args *ptr = (struct thread_args *)args;

    int* arr;
    arr = (int*)calloc(ptr->N,sizeof(int));
    for (int i=0;i<ptr->size;i++) {
        memset(arr,0,ptr->N*sizeof(int));
        bool temp_check = true;
        for (int row = ptr->start_row[i];row<=ptr->end_row[i];row++) {
            for (int col = ptr->start_col[i];col<=ptr->end_col[i];col++) {
                arr[ptr->temp_sudoku[row][col]-1]++;
            }
        }
        for (int j = 0;j<ptr->N;j++) {
            if (arr[j]!=1) {
                temp_check = false;
                // break;
            }
        }
        ptr->check[i] = temp_check;
    }
    free(arr);
}

/*Please give name of input file in command line argument*/
int main(int argc, char **argv)
{
    int N,n,k;
    pthread_t* threads; 
    int** sudoku;
    /*read input file*/
    FILE *input = fopen(argv[1], "r");
    if (input == NULL)
    {
        printf("%s: File doesn't exist\n", argv[1]);
        return 0;
    }
    // Output file to be generated by main thread
    FILE *out_file = fopen("output_pthread.txt", "w");

    // Number of points, number of threads
    if (fscanf(input, "%d %d", &k, &N) != EOF)
    {
        int mod = (3*N)%k, div = (3*N)/k;
        n = sqrt(N);
        
        sudoku = (int**)malloc(N*sizeof(int*));
        for (int i=0;i<N;i++) sudoku[i] = (int*)malloc(N*sizeof(int));

        for (int i=0;i<N;i++) {
            for (int j=0;j<N;j++) fscanf(input,"%d",&sudoku[i][j]);
        }

        // Array of thread identifier of different threads
        threads = (pthread_t*)calloc(k,sizeof(pthread_t));
        pthread_attr_t attr;
        // Set the default attributes of threads
        pthread_attr_init(&attr);

        // Array of arguments to be passed to threads
        struct thread_args arguments[k];

        int count_rows = 0, count_cols = 0, count_grids = 0;

        for (int i = 0; i < k; i++)
        {
            int extra = 0;
            if (mod>0) {
                extra++;
                mod--;
            }
            int size = div+extra;
            int it = 0;
            arguments[i].size = size;
            arguments[i].start_row = (int*)malloc((size)*sizeof(int));
            arguments[i].start_col = (int*)malloc((size)*sizeof(int));
            arguments[i].end_row = (int*)malloc((size)*sizeof(int));
            arguments[i].end_col = (int*)malloc((size)*sizeof(int));
            arguments[i].check = (bool*)malloc((size)*sizeof(bool));
            arguments[i].temp_sudoku = sudoku;
            arguments[i].N = N;
            while (it<size && count_rows < N) {
                arguments[i].start_row[it] = count_rows;
                arguments[i].start_col[it] = 0;
                arguments[i].end_row[it] = count_rows;
                arguments[i].end_col[it] = N-1;
                arguments[i].check[it] = false;
                it++;
                count_rows++;
            }
            while (it<size && count_cols < N) {
                arguments[i].start_row[it] = 0;
                arguments[i].start_col[it] = count_cols;
                arguments[i].end_row[it] = N-1;
                arguments[i].end_col[it] = count_cols;
                arguments[i].check[it] = false;
                it++;
                count_cols++;
            }
            while (it<size && count_grids < N) {
                int temp = count_grids/n;
                arguments[i].start_row[it] = temp*n;
                arguments[i].start_col[it] = (count_grids%n)*n;
                arguments[i].end_row[it] = arguments[i].start_row[it] + n-1;
                arguments[i].end_col[it] = arguments[i].start_col[it] + n-1;
                arguments[i].check[it] = false;
                it++;
                count_grids++;
            }
        }

        // Track of time
        auto start = high_resolution_clock::now();

        // clock_t begin = clock();
        // start timer.

        // Create the threads
        for (int i = 0; i < k; i++)
            pthread_create(&threads[i], &attr, runner, &arguments[i]);

        // Join threads
        for (int i = 0; i < k; i++)
            pthread_join(threads[i], NULL);

        // clock_t end = clock();
        // // Total time spent in microseconds
        auto end = high_resolution_clock::now();
        double time_taken = duration_cast<microseconds>(end - start).count();
        printf("%.4lf\n",time_taken);
        // time_taken += (double)(end - begin) * (M) / CLOCKS_PER_SEC;

        bool final_check = true;

        // Print log in output file
        for (int i = 0; i < k; i++)
        {
            for (int j= 0;j<arguments[i].size;j++) {
                if (arguments[i].start_row[j] == arguments[i].end_row[j]) {
                    fprintf(out_file,"Thread %d checks row %d and is ",i+1,arguments[i].start_row[j]+1);
                }
                else if (arguments[i].start_col[j] == arguments[i].end_col[j]) {
                    fprintf(out_file,"Thread %d checks column %d and is ",i+1,arguments[i].start_col[j]+1);
                }
                else {
                    int quot = arguments[i].start_row[j]/n;
                    int rem = arguments[i].start_col[j]/n;
                    fprintf(out_file,"Thread %d checks grid %d and is ",i+1,n*quot+rem+1);
                }
                if (arguments[i].check[j]) fprintf(out_file, "valid\n");
                else {
                    fprintf(out_file, "invalid\n");
                    final_check = false;
                }
            }
        }
        fprintf(out_file,"\n");
        if (final_check) fprintf(out_file,"Sudoku is valid\n");
        else fprintf(out_file,"Sudoku is invalid\n");

        // Print time taken in output file
        fprintf(out_file, "The total time taken is %.1lf \xC2\xB5s", time_taken);
        
        fclose(input);
        fclose(out_file);
        for (int i=0;i<N;i++) free(sudoku[i]);
        free(sudoku);
        for (int i = 0; i < k; i++) {
            free(arguments[i].start_row);
            free(arguments[i].start_col);
            free(arguments[i].end_row);
            free(arguments[i].end_col);
            free(arguments[i].check);
        }
        free(threads);
    }
    else
    {
        printf("No input written in the file\n");
    }
    return 0;
}