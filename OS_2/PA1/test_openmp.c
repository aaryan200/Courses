/*
C++ program to check if a sudoku is valid using mulithreading with opemp
Author: Aaryan
Roll number: CO21BTECH11001
*/

#include <stdio.h>
#include<stdlib.h>
#include<stdbool.h>
#include<math.h>
#include <omp.h>
#include <sys/stat.h>
#include<string.h>
#include<sys/time.h>
#include <time.h>
#define M 1.0e6

// struct store {
//     bool status;
//     int thread_num;
// };

int N,n,k;
int** sudoku;
// struct store* row_status;
// struct store* col_status;
// struct store* grid_status;

// bool isValidSudoku(int sudoku[N][N]) {
//     bool row_flag[N][N] = {false}, col_flag[N][N] = {false}, box_flag[N][N] = {false};
//     int i, j, k;

//     #pragma omp parallel for collapse(2) private(i,j,k)
//     for (i = 0; i < N; i++) {
//         for (j = 0; j < N; j++) {
//             if (sudoku[i][j] != 0) {
//                 k = sudoku[i][j]-1;
//                 if (row_flag[i][k] || col_flag[j][k] || box_flag[(i/3)*3+j/3][k])
//                     return false;
//                 row_flag[i][k] = col_flag[j][k] = box_flag[(i/3)*3+j/3][k] = true;
//             }
//         }
//     }

//     return true;
// }

int main(int argc, char** argv) {

    /*read input file*/
    FILE *input = fopen(argv[1], "r");
    if (input == NULL)
    {
        printf("%s: File doesn't exist\n", argv[1]);
        return 0;
    }
    // Output file to be generated by main thread
    FILE *out_file = fopen("output_openmp.txt", "w");

    // Number of points, number of threads
    if (fscanf(input, "%d %d", &k, &N) != EOF) {
        n = sqrt(N);
        sudoku = (int**)malloc(N*sizeof(int*));
        for (int i=0;i<N;i++) sudoku[i] = (int*)malloc(N*sizeof(int));

        for (int i=0;i<N;i++) {
            for (int j=0;j<N;j++) fscanf(input,"%d",&sudoku[i][j]);
        }

        omp_set_num_threads(k);
        // int count_rows = 0, count_cols = 0, count_grids = 0;
        // row_status = (struct store*)calloc(N, sizeof(struct store));
        // col_status = (struct store*)calloc(N, sizeof(struct store));
        // grid_status = (struct store*)calloc(N, sizeof(struct store));

        // Track of time
        double time_taken = 0.0;
        struct timeval start, end;
        // start timer.
        gettimeofday(&start, NULL);


        

        #pragma omp parallel for
        for (int count_rows = 0; count_rows<N;count_rows++) {
            bool temp_check = true;
            int* arr;
            arr = (int*)calloc(N,sizeof(int));
            // memset(arr,0,N*sizeof(int));
            for (int col = 0;col<N;col++) arr[sudoku[count_rows][col]-1]++;
            for (int j = 0;j<N;j++) {
                if (arr[j]!=1) {
                    temp_check = false;
                    // break;
                }
            }
            // row_status[count_rows].status = temp_check;
            // row_status[count_rows].thread_num = omp_get_thread_num();
            count_rows++;
            free(arr);
        }

        #pragma omp parallel for
        for (int count_cols = 0; count_cols<N;count_cols++) {
            bool temp_check = true;
            int* arr;
            arr = (int*)calloc(N,sizeof(int));
            // memset(arr,0,N*sizeof(int));
            for (int row = 0;row<N;row++) arr[sudoku[row][count_cols]-1]++;
            for (int j = 0;j<N;j++) {
                if (arr[j]!=1) {
                    temp_check = false;
                    // break;
                }
            }
            col_status[count_cols].status = temp_check;
            col_status[count_cols].thread_num = omp_get_thread_num();
            count_cols++;
            free(arr);
        }

        #pragma omp parallel for
        for (int count_grids = 0;count_grids<N;count_grids++) {
            bool temp_check = true;
            int* arr;
            arr = (int*)calloc(N,sizeof(int));
            // memset(arr,0,N*sizeof(int));
            int temp = count_grids/n;
            int start_row = temp*n;
            int start_col = (count_grids%n)*n;
            for (int row = start_row; row< start_row+n;row++) {
                for (int col = start_col;col<start_col+n;col++) arr[sudoku[row][col]-1]++;
            }
            for (int j = 0;j<N;j++) {
                if (arr[j]!=1) {
                    temp_check = false;
                    // break;
                }
            }
            grid_status[count_grids].status = temp_check;
            grid_status[count_grids].thread_num = omp_get_thread_num();
            count_grids++;
            free(arr);
        }

        gettimeofday(&end, NULL);
        time_taken = (end.tv_sec - start.tv_sec) * M;
        time_taken = (time_taken + (end.tv_usec - start.tv_usec));
        printf("%.1f\n",time_taken);

        bool final_check = true;
        for (int i=0;i<N;i++) {
            fprintf(out_file, "Thread %d checked row %d and is ", row_status[i].thread_num, i+1);
            if (row_status[i].status) fprintf(out_file, "valid\n");
            else {
                fprintf(out_file, "invalid\n");
                final_check = false;
            }
        }

        for (int i=0;i<N;i++) {
            fprintf(out_file, "Thread %d checked column %d and is ", col_status[i].thread_num, i+1);
            if (col_status[i].status) fprintf(out_file, "valid\n");
            else {
                fprintf(out_file, "invalid\n");
                final_check = false;
            }
        }

        for (int i=0;i<N;i++) {
            fprintf(out_file, "Thread %d checked grid %d and is ", grid_status[i].thread_num, i+1);
            if (grid_status[i].status) fprintf(out_file, "valid\n");
            else {
                fprintf(out_file, "invalid\n");
                final_check = false;
            }
        }

        if (final_check) fprintf(out_file,"\nSudoku is valid\n");
        else fprintf(out_file,"\nSudoku is invalid\n");

        // Print time taken in output file
        fprintf(out_file, "The total time taken is %.1lf \xC2\xB5s", time_taken);

        fclose(input);
        fclose(out_file);
        for (int i=0;i<N;i++) free(sudoku[i]);
        free(sudoku);
    }
    else
    {
        printf("No input written in the file\n");
    }

    return 0;
}
